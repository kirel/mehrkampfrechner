<!DOCTYPE html>
<html>
  <head>
    <title>Mehrkampfrechner</title>
    <script type="text/javascript" src="http://www.google.com/jsapi"></script>
    <script src="http://documentcloud.github.com/underscore/underscore-min.js" type="text/javascript"></script>
    <style>
      input.set {
        color: black;
      }
      input.transset {
        color: green;
      }
    </style>
  </head>
  <body>
    <input type="text" name="disc1" value="" id="disc1"/>
    <input type="text" name="pt1" value="" id="pt1"/>
    <br/>
    <input type="text" name="disc2" value="" id="disc2"/>
    <input type="text" name="pt2" value="" id="pt2"/>
    <br/>
    <input type="text" name="total" value="" id="total"/>
    <script type="text/javascript">
      google.load("jquery", "1.4.1");               
      google.setOnLoadCallback(function() {
        /**
        * Nationale Punktetabelle, Ausgabe 1994 des DLV
        *
        * Sie gilt für die Auswertung aller:
        *   Schülermehrkämpfe
        *   Blockwettkämpfe
        *   Mannschaftsmehrkämpfe einschl. DMM, DJMM, DSMM,
        *   DAMM aller Klassen
        */
        
        var frun = function (d,a,c) { return function(m) { return (d/m-a)/c; } }
        var fjump = function (a,c) { return function(m) { return (Math.sqrt(x)-a)/c; } }
        var fthrow = fjump;
        
        var formulasM = {
          "50 m": frun(50, 3.79, 0.0069),
          "60 m": frun(60, 4.20312, 0.00639),
        //  "75 m": [75, 4.1, 0.00664],
        //  "100 m" => [100, 4.34100, 0.00676],
        //  "200 m" => [200, 3.60400, 0.00760],
        //  "400 m" => [400, 2.96700, 0.00716],
        //  "800 m" => [800, 2.32500, 0.00644],
        //  "1.000 m" => [1000, 2.15800, 0.00600],
        //  # TODO 1500-5000
        //  "60 m Hürden" => [60, 3.04, 0.0056],
        //  # TODO andere Hürden
        //  "4 x 75 m Staffel" => [300, 4.1, 0.00338],
          "Weitsprung": fjump(1.15028, 0.00219),
          "200 g Ballwurf": fthrow(1.936, 0.0124)
        }
        
        
        $.mehrkampfrechner = function() {  
          var fst = _(arguments).first();
          var total = $(fst.total);
          var parts = _(arguments).rest();
          total.addClass("unset");
          total.keyup(function () {
            if (total.val()) {
              total.addClass("set").removeClass("unset transset");
            } else {
              total.addClass("unset").removeClass("set transset");
            }
            // update all unset points to (total.value - set.values) / #num of unset values
          });
                          
          total.bind('update', function (evt) {
            var pts = $(_(parts).chain().pluck('pt').value().join(', ')).toArray();
            var unset = _(pts).filter(function(pt) { return $(pt).hasClass("unset"); })
            // if none of the pts is unset
            if (unset.length == 0) {
              console.log('updating total');
              total.addClass("transset").removeClass("set unset");
              var res = 0.0
              $.each(parts, function(index, val) {
                console.log(val.parsept($(val.pt).val()));
                res += val.parsept($(val.pt).val());
              });
              total.val(fst.showtotal(res));
            }
            else if (!total.hasClass("set")) {
              total.addClass("unset").removeClass("transset unset");
              total.val("");
            }
            else {
              // total is set manually - thus update all unset pts TODO
              $.each(parts, function(index, val) {
                console.log(val.parsept($(val.pt).val()));
                res += val.parsept($(val.pt).val());
              });
            }
          });
          
          // var updateUnset = function () {
          //   if (total.hasClass('set')) {
          //     // compute total.val() - $(".set", pts).vals
          //     _($(".unset", pts)).each(function(){
          //       // compute 
          //     })
          //   }
          // }
          
          var coderange = function(from, to) { return function(code) { return code >= from && code <= to; } }
          var tab = coderange(9,9)
          var atoz = coderange(65,90);
          var digit = coderange(48,57);
          var arrows = coderange(37,40); // left up right down
          
          $.each(parts, function(index, val) {
            var pt = $(val.pt);
            var disc = $(val.disc);
            pt.addClass("unset");
            disc.addClass("unset");
            
            pt.change(function (evt) { disc.trigger('update'); });
            disc.change(function (evt) { pt.trigger('update'); });
            
            pt.keyup(function(evt) {
              if (evt.keyCode == 9) return;
              if (pt.val()) {
                pt.addClass("set").removeClass("unset transset");
              } else {
                pt.addClass("unset").removeClass("set transset");
              }
              // update disc
              disc.trigger('update');
            });            
            disc.keyup(function (evt) {
              if (evt.keyCode == 9) return;
              if (disc.val()) {
                disc.addClass("set").removeClass("unset transset");
              } else {
                disc.addClass("unset").removeClass("set transset");
              }
              // update pt
              pt.trigger('update');
            });

            pt.bind('update', function (evt) {
              // get the info from disc
              console.log('updating pt');
              if (disc.val()) {
                pt.addClass("transset").removeClass("set unset");
                var compute = _.compose(val.showpt, val.disc2pt, val.parsedisc);
                pt.val(compute(disc.val()));
              } else {
                pt.addClass("unset").removeClass("set transset");
                pt.val("");
              }
              total.trigger('update');
              // TODO update all unset points to (total.value - set.values) #num of unset values unless total is unset
            });
            disc.bind('update', function (evt) {
              console.log('updating disc');
              if (pt.val()) {
                disc.addClass("transset").removeClass("set unset");
                var compute = _.compose(val.showdisc, val.pt2disc, val.parsept);
                disc.val(compute(pt.val()));
              } else {
                disc.addClass("unset").removeClass("set transset");
                disc.val("");
              }
              total.trigger('update');
              // TODO update all unset points to (total.value - set.values) #num of unset values unless total is unset
            });
          });
        }
          
        $.mehrkampfrechner(
          {
            total:  "#total",
            parsetotal: parseFloat,
            showtotal: _.identity            
          },
          {
            disc:    "#disc1",
            pt:      "#pt1",
            pt2disc: function (x) { return 2*x; },
            disc2pt: function (x) { return x/2; },
            parsedisc: parseFloat,
            parsept: parseFloat,
            showdisc: _.identity,
            showpt: _.identity
          },
          {
            disc:    "#disc2",
            pt:      "#pt2",
            pt2disc: function (x) { return 2*x; },
            disc2pt: function (x) { return x/2; },
            parsedisc: parseFloat,
            parsept: parseFloat,
            showdisc: _.identity,
            showpt: _.identity
          }        
          );
        });
    </script>
  </body>
</html>